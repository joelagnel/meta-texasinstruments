From b952beeefdee9cd381ccddbc8513d739e1c2fca3 Mon Sep 17 00:00:00 2001
From: Hebbar, Gururaja <gururaja.hebbar@ti.com>
Date: Tue, 27 Sep 2011 23:32:00 +0530
Subject: [PATCH 19/20] ARM:omap:am33xx: Register HSMMC Platform on AM335x EVM

This patch adds the hardware info like pin-mux, platform data and
registers the MMC module. All the three MMC instances are supported

Signed-off-by: Hebbar, Gururaja <gururaja.hebbar@ti.com>
---
 arch/arm/mach-omap2/board-am335xevm.c    |  129 ++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/clock335x_data.c     |   12 ++--
 arch/arm/mach-omap2/hsmmc.c              |   12 ++-
 arch/arm/plat-omap/include/plat/am33xx.h |    4 +
 4 files changed, 148 insertions(+), 9 deletions(-)

diff --git a/arch/arm/mach-omap2/board-am335xevm.c b/arch/arm/mach-omap2/board-am335xevm.c
index ff93fe4..0457556 100644
--- a/arch/arm/mach-omap2/board-am335xevm.c
+++ b/arch/arm/mach-omap2/board-am335xevm.c
@@ -40,6 +40,7 @@
 #include <plat/common.h>
 #include <plat/lcdc.h>
 #include <plat/usb.h>
+#include <plat/mmc.h>
 
 /* LCD controller is similar to DA850 */
 #include <video/da8xx-fb.h>
@@ -47,6 +48,7 @@
 #include "board-flash.h"
 #include "mux.h"
 #include "devices.h"
+#include "hsmmc.h"
 
 static const struct display_panel disp_panel = {
 	WVGA,
@@ -129,6 +131,24 @@ static struct snd_platform_data am335x_evm_snd_data1 = {
 	.rxnumevt	= 1,
 };
 
+static struct omap2_hsmmc_info am335x_mmc[] __initdata = {
+	{
+		.mmc            = 1,
+		.caps           = MMC_CAP_4_BIT_DATA,
+		.gpio_cd        = -EINVAL,/* Dedicated pins for CD and WP */
+		.gpio_wp        = -EINVAL,
+		.ocr_mask       = MMC_VDD_32_33 | MMC_VDD_33_34, /* 3V3 */
+	},
+	{
+		.mmc            = 0,	/* will be set at runtime */
+	},
+	{
+		.mmc            = 0,	/* will be set at runtime */
+	},
+	{}      /* Terminator */
+};
+
+
 #ifdef CONFIG_OMAP_MUX
 static struct omap_board_mux board_mux[] __initdata = {
 	AM335X_MUX(I2C0_SDA, OMAP_MUX_MODE0 | AM335X_SLEWCTRL_SLOW |
@@ -394,6 +414,65 @@ static struct pinmux_config mcasp1_pin_mux[] = {
 	{NULL, 0},
 };
 
+
+/* Module pin mux for mmc0 */
+static struct pinmux_config mmc0_pin_mux[] = {
+	{"mmc0_dat3.mmc0_dat3",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mmc0_dat2.mmc0_dat2",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mmc0_dat1.mmc0_dat1",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mmc0_dat0.mmc0_dat0",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mmc0_clk.mmc0_clk",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mmc0_cmd.mmc0_cmd",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mcasp0_aclkr.mmc0_sdwp", OMAP_MUX_MODE4 | AM335X_PIN_INPUT_PULLDOWN},
+	{"spi0_cs1.mmc0_sdcd",  OMAP_MUX_MODE5 | AM335X_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+static struct pinmux_config mmc0_no_cd_pin_mux[] = {
+	{"mmc0_dat3.mmc0_dat3",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mmc0_dat2.mmc0_dat2",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mmc0_dat1.mmc0_dat1",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mmc0_dat0.mmc0_dat0",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mmc0_clk.mmc0_clk",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mmc0_cmd.mmc0_cmd",	OMAP_MUX_MODE0 | AM335X_PIN_INPUT_PULLUP},
+	{"mcasp0_aclkr.mmc0_sdwp", OMAP_MUX_MODE4 | AM335X_PIN_INPUT_PULLDOWN},
+	{NULL, 0},
+};
+
+/* Module pin mux for mmc1 */
+static struct pinmux_config mmc1_pin_mux[] = {
+	{"gpmc_ad7.mmc1_dat7",	OMAP_MUX_MODE1 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad6.mmc1_dat6",	OMAP_MUX_MODE1 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad5.mmc1_dat5",	OMAP_MUX_MODE1 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad4.mmc1_dat4",	OMAP_MUX_MODE1 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad3.mmc1_dat3",	OMAP_MUX_MODE1 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad2.mmc1_dat2",	OMAP_MUX_MODE1 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad1.mmc1_dat1",	OMAP_MUX_MODE1 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad0.mmc1_dat0",	OMAP_MUX_MODE1 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_csn1.mmc1_clk",	OMAP_MUX_MODE2 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_csn2.mmc1_cmd",	OMAP_MUX_MODE2 | AM335X_PIN_INPUT_PULLUP},
+	{"uart1_rxd.mmc1_sdwp",	OMAP_MUX_MODE1 | AM335X_PIN_INPUT_PULLUP},
+	{"mcasp0_fsx.mmc1_sdcd", OMAP_MUX_MODE4 | AM335X_PIN_INPUT_PULLDOWN},
+	{NULL, 0},
+};
+
+/* Module pin mux for mmc2 */
+static struct pinmux_config mmc2_pin_mux[] = {
+	{"gpmc_ad11.mmc2_dat7",	OMAP_MUX_MODE3 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad10.mmc2_dat6",	OMAP_MUX_MODE3 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad9.mmc2_dat5",	OMAP_MUX_MODE3 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad8.mmc2_dat4",	OMAP_MUX_MODE3 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad15.mmc2_dat3",	OMAP_MUX_MODE3 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad14.mmc2_dat2",	OMAP_MUX_MODE3 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad13.mmc2_dat1",	OMAP_MUX_MODE3 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_ad12.mmc2_dat0",	OMAP_MUX_MODE3 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_clk.mmc2_clk",	OMAP_MUX_MODE3 | AM335X_PIN_INPUT_PULLUP},
+	{"gpmc_csn3.mmc2_cmd",	OMAP_MUX_MODE3 | AM335X_PIN_INPUT_PULLUP},
+	{"spi0_cs0.mmc2_sdwp",	OMAP_MUX_MODE1 | AM335X_PIN_INPUT_PULLDOWN},
+	{"mcasp0_axr0.mmc2_sdcd", OMAP_MUX_MODE4 | AM335X_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
 /*
 * @pin_mux - single module pin-mux structure which defines pin-mux
 *			details for all its pins.
@@ -634,6 +713,51 @@ static void mcasp1_init(int evm_id, int profile)
 	return;
 }
 
+static void mmc1_init(int evm_id, int profile)
+{
+	setup_pin_mux(mmc1_pin_mux);
+
+	am335x_mmc[1].mmc = 2;
+	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA;
+	am335x_mmc[1].gpio_cd = -EINVAL;
+	am335x_mmc[1].gpio_wp = -EINVAL;
+	am335x_mmc[1].ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34; /* 3V3 */
+
+	/* mmc will be initialized when mmc0_init is called */
+	return;
+}
+
+static void mmc2_init(int evm_id, int profile)
+{
+	setup_pin_mux(mmc2_pin_mux);
+
+	am335x_mmc[1].mmc = 3;
+	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA;
+	am335x_mmc[1].gpio_cd = -EINVAL;
+	am335x_mmc[1].gpio_wp = -EINVAL;
+	am335x_mmc[1].ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34; /* 3V3 */
+
+	/* mmc will be initialized when mmc0_init is called */
+	return;
+}
+
+static void mmc0_init(int evm_id, int profile)
+{
+	setup_pin_mux(mmc0_pin_mux);
+
+	omap2_hsmmc_init(am335x_mmc);
+	return;
+}
+
+static void mmc0_no_cd_init(int evm_id, int profile)
+{
+	setup_pin_mux(mmc0_no_cd_pin_mux);
+
+	omap2_hsmmc_init(am335x_mmc);
+	return;
+}
+
+
 /* Low-Cost EVM */
 static struct evm_dev_cfg low_cost_evm_dev_cfg[] = {
 	{rgmii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
@@ -660,6 +784,10 @@ static struct evm_dev_cfg gen_purp_evm_dev_cfg[] = {
 		(PROFILE_ALL & ~PROFILE_2 & ~PROFILE_3)},
 	{i2c1_init,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_3 | PROFILE_7)},
 	{mcasp1_init,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_3) },
+	{mmc1_init,	DEV_ON_DGHTR_BRD, PROFILE_2},
+	{mmc2_init,	DEV_ON_DGHTR_BRD, PROFILE_4},
+	{mmc0_init,	DEV_ON_BASEBOARD, (PROFILE_ALL & ~PROFILE_5)},
+	{mmc0_no_cd_init,	DEV_ON_BASEBOARD, PROFILE_5},
 	{NULL, 0, 0},
 };
 
@@ -684,6 +812,7 @@ static struct evm_dev_cfg ip_phn_evm_dev_cfg[] = {
 	{evm_nand_init, DEV_ON_DGHTR_BRD, PROFILE_NONE},
 	{i2c1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{mcasp1_init,	DEV_ON_DGHTR_BRD, PROFILE_NONE},
+	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{NULL, 0, 0},
 };
 
diff --git a/arch/arm/mach-omap2/clock335x_data.c b/arch/arm/mach-omap2/clock335x_data.c
index 5920e05..711a50b 100644
--- a/arch/arm/mach-omap2/clock335x_data.c
+++ b/arch/arm/mach-omap2/clock335x_data.c
@@ -1758,12 +1758,12 @@ static struct omap_clk am335x_clks[] = {
 	CLK("davinci-mcasp.0",	NULL,		&mcasp0_fck,	CK_AM335X),
 	CLK("davinci-mcasp.1",	NULL,		&mcasp1_fck,	CK_AM335X),
 	CLK(NULL,	"mlb_fck",		&mlb_fck,	CK_AM335X),
-	CLK("mmci-omap-hs.0",	"ick",	&mmc0_ick,	CK_AM335X),
-	CLK("mmci-omap-hs.1",	"ick",	&mmc1_ick,	CK_AM335X),
-	CLK("mmci-omap-hs.2",	"ick",	&mmc2_ick,	CK_AM335X),
-	CLK("mmci-omap-hs.0",	"fck",	&mmc0_fck,	CK_AM335X),
-	CLK("mmci-omap-hs.1",	"fck",	&mmc1_fck,	CK_AM335X),
-	CLK("mmci-omap-hs.2",	"fck",	&mmc2_fck,	CK_AM335X),
+	CLK("omap_hsmmc.0",	"ick",		&mmc0_ick,	CK_AM335X),
+	CLK("omap_hsmmc.1",	"ick",		&mmc1_ick,	CK_AM335X),
+	CLK("omap_hsmmc.2",	"ick",		&mmc2_ick,	CK_AM335X),
+	CLK("omap_hsmmc.0",	"fck",		&mmc0_fck,	CK_AM335X),
+	CLK("omap_hsmmc.1",	"fck",		&mmc1_fck,	CK_AM335X),
+	CLK("omap_hsmmc.2",	"fck",		&mmc2_fck,	CK_AM335X),
 	CLK(NULL,	"mmu_fck",		&mmu_fck,	CK_AM335X),
 	CLK(NULL,	"mpu_ck",		&mpu_fck,	CK_AM335X),
 	CLK(NULL,	"mstr_exps_fck",	&mstr_exps_fck,	CK_AM335X),
diff --git a/arch/arm/mach-omap2/hsmmc.c b/arch/arm/mach-omap2/hsmmc.c
index a9b45c7..d2e78ad 100644
--- a/arch/arm/mach-omap2/hsmmc.c
+++ b/arch/arm/mach-omap2/hsmmc.c
@@ -302,6 +302,9 @@ static int __init omap_hsmmc_pdata_init(struct omap2_hsmmc_info *c,
 		return -ENOMEM;
 	}
 
+	if (cpu_is_am33xx())
+		mmc->version = MMC_CTRL_VERSION_2;
+
 	if (c->name)
 		strncpy(hc_name, c->name, HSMMC_NAME_LEN);
 	else
@@ -352,12 +355,13 @@ static int __init omap_hsmmc_pdata_init(struct omap2_hsmmc_info *c,
 	 */
 	mmc->slots[0].ocr_mask = c->ocr_mask;
 
-	if (cpu_is_omap3517() || cpu_is_omap3505())
+	if (cpu_is_omap3517() || cpu_is_omap3505() || cpu_is_am33xx())
 		mmc->slots[0].set_power = nop_mmc_set_power;
 	else
 		mmc->slots[0].features |= HSMMC_HAS_PBIAS;
 
-	if (cpu_is_omap44xx() && (omap_rev() > OMAP4430_REV_ES1_0))
+	if ((cpu_is_omap44xx() && (omap_rev() > OMAP4430_REV_ES1_0)) ||
+								cpu_is_am33xx())
 		mmc->slots[0].features |= HSMMC_HAS_UPDATED_RESET;
 
 	switch (c->mmc) {
@@ -449,7 +453,9 @@ void __init omap_init_hsmmc(struct omap2_hsmmc_info *hsmmcinfo, int ctrl_nr)
 		pr_err("%s fails!\n", __func__);
 		goto done;
 	}
-	omap_hsmmc_mux(mmc_data, (ctrl_nr - 1));
+
+	if (!cpu_is_am335x())
+		omap_hsmmc_mux(mmc_data, (ctrl_nr - 1));
 
 	name = "omap_hsmmc";
 	ohl = omap_hsmmc_latency;
diff --git a/arch/arm/plat-omap/include/plat/am33xx.h b/arch/arm/plat-omap/include/plat/am33xx.h
index 79c5cf6..cfec459 100644
--- a/arch/arm/plat-omap/include/plat/am33xx.h
+++ b/arch/arm/plat-omap/include/plat/am33xx.h
@@ -32,4 +32,8 @@
 #define AM335X_ASP0_BASE	0x48038000
 #define AM335X_ASP1_BASE	0x4803C000
 
+#define AM335X_MMC0_BASE	0x48060100
+#define AM335X_MMC1_BASE	0x481D8100
+#define AM335X_MMC2_BASE	0x47810100
+
 #endif /* __ASM_ARCH_AM33XX_H */
-- 
1.6.6.1

