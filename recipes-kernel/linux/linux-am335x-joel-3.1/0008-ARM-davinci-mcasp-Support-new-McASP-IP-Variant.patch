From abeaaf2460f6e1d7ec7e3fc88ca50b145f9e342c Mon Sep 17 00:00:00 2001
From: Hebbar, Gururaja <gururaja.hebbar@ti.com>
Date: Fri, 23 Sep 2011 17:47:35 +0530
Subject: [PATCH 08/20] ARM:davinci:mcasp: Support new McASP IP Variant

Few OMAP platform has a new Variant of McASP than those found on Davinci
Platform.

This patch adds support for the same.

Changes
- Add new MCASP_VERSION_3 to identify new IP
- The FIFO offsets for the McASP in new platform are different from the
  ones seen on previous varianats. Use version member to identify and
  process accordingly

This has been tested on DM365 platform to make sure nothing existing
breaks

Signed-off-by: Hebbar, Gururaja <gururaja.hebbar@ti.com>
---
 arch/arm/include/asm/hardware/asp.h |    1 +
 sound/soc/davinci/davinci-mcasp.c   |   92 +++++++++++++++++++++++++++-------
 2 files changed, 74 insertions(+), 19 deletions(-)

diff --git a/arch/arm/include/asm/hardware/asp.h b/arch/arm/include/asm/hardware/asp.h
index 6083870..e3d7d7e 100644
--- a/arch/arm/include/asm/hardware/asp.h
+++ b/arch/arm/include/asm/hardware/asp.h
@@ -120,6 +120,7 @@ struct snd_platform_data {
 enum {
 	MCASP_VERSION_1 = 0,	/* DM646x */
 	MCASP_VERSION_2,	/* DA8xx/OMAPL1x */
+	MCASP_VERSION_3,
 };
 
 enum dm365_clk_input_pin {
diff --git a/sound/soc/davinci/davinci-mcasp.c b/sound/soc/davinci/davinci-mcasp.c
index 8566238..4c491c9 100644
--- a/sound/soc/davinci/davinci-mcasp.c
+++ b/sound/soc/davinci/davinci-mcasp.c
@@ -108,6 +108,10 @@
 #define DAVINCI_MCASP_WFIFOSTS		(0x1014)
 #define DAVINCI_MCASP_RFIFOCTL		(0x1018)
 #define DAVINCI_MCASP_RFIFOSTS		(0x101C)
+#define MCASP_VER3_WFIFOCTL		(0x1000)
+#define MCASP_VER3_WFIFOSTS		(0x1004)
+#define MCASP_VER3_RFIFOCTL		(0x1008)
+#define MCASP_VER3_RFIFOSTS		(0x100C)
 
 /*
  * DAVINCI_MCASP_PWREMUMGT_REG - Power Down and Emulation Management
@@ -380,14 +384,28 @@ static void mcasp_start_tx(struct davinci_audio_dev *dev)
 static void davinci_mcasp_start(struct davinci_audio_dev *dev, int stream)
 {
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		if (dev->txnumevt)	/* enable FIFO */
-			mcasp_set_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,
-								FIFO_ENABLE);
+		if (dev->txnumevt) {	/* enable FIFO */
+			if (dev->version == MCASP_VERSION_3)
+				mcasp_set_bits(dev->base +
+						MCASP_VER3_WFIFOCTL,
+						FIFO_ENABLE);
+			else
+				mcasp_set_bits(dev->base +
+						DAVINCI_MCASP_WFIFOCTL,
+						FIFO_ENABLE);
+		}
 		mcasp_start_tx(dev);
 	} else {
-		if (dev->rxnumevt)	/* enable FIFO */
-			mcasp_set_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,
-								FIFO_ENABLE);
+		if (dev->rxnumevt) {	/* enable FIFO */
+			if (dev->version == MCASP_VERSION_3)
+				mcasp_set_bits(dev->base +
+						MCASP_VER3_WFIFOCTL,
+						FIFO_ENABLE);
+			else
+				mcasp_set_bits(dev->base +
+						DAVINCI_MCASP_RFIFOCTL,
+						FIFO_ENABLE);
+		}
 		mcasp_start_rx(dev);
 	}
 }
@@ -407,14 +425,28 @@ static void mcasp_stop_tx(struct davinci_audio_dev *dev)
 static void davinci_mcasp_stop(struct davinci_audio_dev *dev, int stream)
 {
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		if (dev->txnumevt)	/* disable FIFO */
-			mcasp_clr_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,
-								FIFO_ENABLE);
+		if (dev->txnumevt) {	/* disable FIFO */
+			if (dev->version == MCASP_VERSION_3)
+				mcasp_clr_bits(dev->base +
+						MCASP_VER3_WFIFOCTL,
+						FIFO_ENABLE);
+			else
+				mcasp_clr_bits(dev->base +
+						DAVINCI_MCASP_WFIFOCTL,
+						FIFO_ENABLE);
+		}
 		mcasp_stop_tx(dev);
 	} else {
-		if (dev->rxnumevt)	/* disable FIFO */
-			mcasp_clr_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,
-								FIFO_ENABLE);
+		if (dev->rxnumevt) {	/* disable FIFO */
+			if (dev->version == MCASP_VERSION_3)
+				mcasp_clr_bits(dev->base +
+						MCASP_VER3_RFIFOCTL,
+						FIFO_ENABLE);
+			else
+				mcasp_clr_bits(dev->base +
+						DAVINCI_MCASP_RFIFOCTL,
+						FIFO_ENABLE);
+		}
 		mcasp_stop_rx(dev);
 	}
 }
@@ -613,20 +645,36 @@ static void davinci_hw_common_param(struct davinci_audio_dev *dev, int stream)
 		if (dev->txnumevt * tx_ser > 64)
 			dev->txnumevt = 1;
 
-		mcasp_mod_bits(dev->base + DAVINCI_MCASP_WFIFOCTL, tx_ser,
+		if (dev->version == MCASP_VERSION_3) {
+			mcasp_mod_bits(dev->base + MCASP_VER3_WFIFOCTL, tx_ser,
 								NUMDMA_MASK);
-		mcasp_mod_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,
+			mcasp_mod_bits(dev->base + MCASP_VER3_WFIFOCTL,
+				((dev->txnumevt * tx_ser) << 8), NUMEVT_MASK);
+		} else {
+			mcasp_mod_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,
+							tx_ser, NUMDMA_MASK);
+			mcasp_mod_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,
 				((dev->txnumevt * tx_ser) << 8), NUMEVT_MASK);
+		}
 	}
 
 	if (dev->rxnumevt && stream == SNDRV_PCM_STREAM_CAPTURE) {
 		if (dev->rxnumevt * rx_ser > 64)
 			dev->rxnumevt = 1;
 
-		mcasp_mod_bits(dev->base + DAVINCI_MCASP_RFIFOCTL, rx_ser,
+		if (dev->version == MCASP_VERSION_3) {
+			mcasp_mod_bits(dev->base + MCASP_VER3_RFIFOCTL, rx_ser,
 								NUMDMA_MASK);
-		mcasp_mod_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,
-				((dev->rxnumevt * rx_ser) << 8), NUMEVT_MASK);
+			mcasp_mod_bits(dev->base + MCASP_VER3_RFIFOCTL,
+					((dev->rxnumevt * rx_ser) << 8),
+					NUMEVT_MASK);
+		} else {
+			mcasp_mod_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,
+							rx_ser,	NUMDMA_MASK);
+			mcasp_mod_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,
+					((dev->rxnumevt * rx_ser) << 8),
+					NUMEVT_MASK);
+		}
 	}
 }
 
@@ -910,7 +958,10 @@ static int davinci_mcasp_probe(struct platform_device *pdev)
 	dma_data->asp_chan_q = pdata->asp_chan_q;
 	dma_data->ram_chan_q = pdata->ram_chan_q;
 	dma_data->sram_size = pdata->sram_size_playback;
-	dma_data->dma_addr = (dma_addr_t) (pdata->tx_dma_offset +
+	if (dev->version == MCASP_VERSION_3)
+		dma_data->dma_addr = (dma_addr_t) (pdata->tx_dma_offset);
+	else
+		dma_data->dma_addr = (dma_addr_t) (pdata->tx_dma_offset +
 							mem->start);
 
 	/* first TX, then RX */
@@ -927,7 +978,10 @@ static int davinci_mcasp_probe(struct platform_device *pdev)
 	dma_data->asp_chan_q = pdata->asp_chan_q;
 	dma_data->ram_chan_q = pdata->ram_chan_q;
 	dma_data->sram_size = pdata->sram_size_capture;
-	dma_data->dma_addr = (dma_addr_t)(pdata->rx_dma_offset +
+	if (dev->version == MCASP_VERSION_3)
+		dma_data->dma_addr = (dma_addr_t) (pdata->rx_dma_offset);
+	else
+		dma_data->dma_addr = (dma_addr_t)(pdata->rx_dma_offset +
 							mem->start);
 
 	res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
-- 
1.6.6.1

